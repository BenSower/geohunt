<!DOCTYPE html>
<html lang="en">

<head>
    <% include includes/head.html %>
</head>

<body>

    <div class="container">
            <% include includes/header.html%>
        <div class="jumbotron">
			GeoHunt ist eine Website, die den Nutzern erlaubt, Spatial Tasks zu stellen und gleichzeitig Anreize dafür zu schaffen, sie zu erfüllen. Dafür werden die Spatial Tasks in eine ortsbezogene Schnitzeljagd eingebettet, an der die Nutzer zum eigenen Vergnügen teilnehmen. Beim Erstellen eines Tasks muss gleichzeitig ein Rätsel für die Schnitzeljagd gestellt werden. Möchte ein Nutzer dann eine Schnitzeljagd spielen, stellt GeoHunt ihm Rätsel in seiner Nähe. <br>
			Hat der Nutzer ein Rätsel gelöst, muss er sich an den angegebenen Ort begeben. Dort wird er dann aufgefordert, ein Video mit der mediaQ - App aufzunehmen (und es bei Abschluss der Schnitzeljagd in die mediaQ-Datenbank zu laden). <br>
			GeoHunt wurde von Julia Kinshofer(B.Sc.), Benjamin Sauer(B.Sc.) und Daniel Basaran(B.Sc.) im Rahmen des Hauptseminars „MediaQ: Practical Seminar on Big Data for Social Media“ von Dr Matthias Renz am Institut für Informatik der Ludwig-Maximilians-Universität in München entwickelt.

        </div>
        <% include includes/foot.html %>



        <div>
        <h3>Documentation:</h3>

<h4>Motivation:</h4>
<br>

Im Rahmen des Seminars haben sich die Autoren speziell mit dem Paper Leyla Kazemi, Cyrus Shahabi. GeoCrowd: Enabling Query Answering with Spatial Crowdsourcing. In Proc. GIS (2012). beschäftigt. Dieses Paper bearbeitet die Probleme bei Spatial Crowdsourcing: Wie können Spatial Tasks effizient Usern zugewiesen werden und wie motiviert man User, diese Tasks auch zu erfüllen?<br> <br>

Besondere Probleme bereitet dabei die Tatsache, dass die Erfüllung von Spatial Tasks für den Nutzer immer mit bestimmten Kosten verbunden ist: Er muss zunächst einmal zu dem Ort des Tasks reisen. Deswegen muss zunächst ein ausreichender Anreiz für den User geschaffen werden, den Task erfüllen zu wollen. <br> <br>

Des Weiteren müssen - im Rahmen einer Schnitzeljagd - die Wege zwischen den Spatial Tasks vereinheitlicht werden, das heißt die Tasks Ti müssen in einer Reihenfolge vergeben werden, die sicherstellt dass der Weg von Task Ti zu Tj für alle i und j durchschnittlich lang ist sowie dass die Gesamtstrecke einer Schnitzeljagd nicht zu lange wird. <br> <br>

Schlussendlich muss noch gewährleistet werden, dass die Schnitzeljagd an einer Location mit kostenlosem Internetzugang (Free-WiFi) endet, damit die Nutzer ihre Videos in der mediaQ-App auch in die Datenbank hochladen können, ohne ihre eigene Bandbreite zu verschwenden. <br> <br> <br>



<h4>Formale Problemdefinition:</h4><br>

(A)Seien Ti und Tj Spatial Tasks, mit i,j element {1,…,5} und i!=j.
Sei |Ti->Tj| die Länge des Weges vom Ort von Ti zum Ort von Tj.
Dann muss für alle i, j gelten:
|Ti->Tj| / avg(|Ti->Tj|) < 1+ epsilon.
epsilon soll minimiert werden.<br> <br>

(B)Sei Pn die Position des Nutzers, der eine Schnitzeljagd spielen will, und r der Radius innerhalb dessen er sich bewegen kann. Seien Ti die Tasks, die noch nicht erfüllt sind.
Dann muss dem Nutzer eine Schnitzeljagd zugewiesen werden, sodass gilt:
Tj (0 kleinerj kleiner 6) aus Ti mit dist(Tj, Pn) kleiner r und T5 muss in der Nähe eines WiFi-Hotspots liegen.<br> <br>

(C)Generell muss dem Nutzer ein Anreiz A gegeben werden, den Spatial Task auszuführen, d.h. die Kosten K der Reise an den Ort des Tasks auf sich nehmen. D.h. Ai > Ki für alle Spatial Tasks. <br> <br> <br>



<h4>Algorithmische Lösung:</h4><br>

Problem C kann nicht direkt algorithmisch gelöst werden, dennoch stellt das Schaffen geeigneter Anreize für das Erfüllen der Spatial Tasks den Kernpunkt der Arbeit der Autoren dar. Wie kann man jemandem einen Anreiz geben, an irgendeinen Ort zu fahren und dort ein Video mit der mediaQ-App aufzuzeichnen?<br> <br>

Nach einigem Überlegen haben sich die Autoren entschieden, die Spatial  Tasks in ein Spiel einzubinden, da bei Spielen das Gewinnen bzw. das Spielen selbst Anreiz genug ist, Anweisungen auszuführen. Hierfür bot sich eine Schnitzeljagd an, bei der man von Ort zu Ort reisen muss, um irgendwann zu gewinnen. Dementsprechend wurde GeoHunt entwickelt. Wie bei traditionellen Schnitzeljagden muss der Spieler Rätsel lösen, die mit dem Ort des Spatial Tasks verbunden sind. Dann muss er an den Ort reisen und ein Video mit der MediaQ-App aufnehmen, um anschließend das nächste Rätsel zu lösen.<br> <br>

Hierbei ergeben sich natürlich einige Probleme, das wichtigste ist die Erstellung des Rätsels. Es existiert keine AI, die ein Rätsel für eine Schnitzeljagd erstellen kann. Deswegen haben die Autoren sich entschieden, die Rätsel vom Taskersteller  selbst  stellen zu lassen.
Wichtig ist hierbei, dass die Rätsel auch (mit Hilfe einer Websuche) lösbar sind und dass man dabei auch etwas lernt, zB über die Geschichte eines Points of Interest, von dem das Video erstellt werden soll.<br> <br>

Dieses Lernen bietet dann auch einen zusätzlichen Anreiz, sich an GeoHunt zu beteiligen. Vor allem Schulklassen könnten die Schnitzeljagden mit Schulausflügen verbinden, bei denen sie etwas über die Geschichte ihrer Heimatstadt lernen und dann mehrere Videos eines Point of Interest aus verschiedenen Perspektiven in die mediaQ-Datenbank hochladen.<br> <br>
Damit ein Spiel Spaß macht, muss es einfach zu bedienen sein und eine ansprechende, wenn möglich lustige Oberfläche haben. Deshalb haben die Autoren den Schwerpunkt ihrer Arbeit auf die Präsentation des Spiels gelegt, die Bedienung soll interaktiv sein und die Website schön gestaltet. Die Einführung der Figur „…“, die durch die Schnitzeljagd führt, soll den Spielspaß steigern.<br> <br>

All diese Punkte dienen dazu, den Anreiz zu schaffen, die Spatial Tasks auszuführen. Dafür müssen dem Nutzer aber erst einmal die Rätsel entsprechend Problem B zugewiesen werden.<br> <br>


Grundsätzlich handelt es sich bei Problem B um ein bekanntes Problem aus der Informatik, einer Point-In-Polygon-Query, wobei das betrachtete Polygon ein Kreis um den Nutzer mit Radius r ist und der Punkt ein Spatial Task.<br> <br>

Die Intuitive Lösung wäre, die Distanz aller Tasks in der DB zum Spieler zu berechnen und dann die Tasks auszuwählen, deren Distanz kleiner als der Radius ist. Aus diesen Tasks könnte man dann 5 mit hoher Priorität auswählen und zu einer Schnitzeljagd verbinden. Bei wenigen Nutzern und Tasks wäre diese Lösung auch noch vertretbar (lineare Komplexität), doch sollte GeoHunt weltweit gespielt werden, würden viele sinnlose Distanzberechnungen durchgeführt.<br> <br>

Deswegen gibt es bessere algorithmische Ansätze. Organisiert man die Tasks nicht linear, sondern in einer Baumstruktur, kann man sich viele Distanzberechnungen sparen, indem man sich auf einen relevanten Zweig im Baum beschränkt, muss allerdings eine höhere Zeit beim Erstellen eines Tasks aufwenden, da man den Tasks in einen Baum und nicht in eine Liste einfügen muss.<br> <br>
Da man aber davon ausgehen kann, dass jeder Task mehrmals zugewiesen wird (wenn jeder, der einen Task erstellt, dafür 1 mal spielt, werden ihm bereits 5 Tasks zugewiesen) und dass beim Erstellen des Tasks mehr Zeit vorhanden ist als beim Spielen, so ist dieser Nachteil unproblematisch.<br> <br>

Eine weitere Möglichkeit wäre, die Tasks in mehreren Listen abzuspeichern, sodass jeder Task nur in der Liste seiner Stadt steht. Bei der Rätselzuweisung würde dann nur auf die Liste der Stadt, in der sich der Spieler befindet, zugegriffen, in dieser könnte dann wieder linear gesucht werden.<br> <br>

Problem A ist nur in quadratischer Laufzeit lösbar (Distanzen aller Tasks zu einander müssen berechnet werden, dann muss ein optimaler Weg gefunden werden).<br> <br>
Damit kann man aber umgehen, wenn man den Weg nur für eine begrenzte Anzahl Tasks berechnet. Hierfür bietet es sich an, zuerst Problem B zu lösen und fünf Tasks in der Umgebung des Spielers auszuwählen, die eine hohe Priorität haben. Dann muss man nur noch die optimale Reihenfolge dieser 5 Rätsel berechnen, indem man versucht, die Gesamtstrecke, die zwischen den Tasks zurück gelegt werden muss, an einen Basiswert anzugleichen. Und auf einer Eingabemenge von 5 Objekten ist eine quadratische Laufzeit unproblematisch.<br> <br>

Input: 5 Spatial Tasks und Baseline (gewünschte Gesamtstreckenlänge)<br>
Berechne paarweise Distanzen der 5 Spatial Tanks<br>
Berechne die 5! möglichen Permutationen der Spatial-Tasks sowie deren Gesamtwegstrecke<br>
Wähle die Permutation, bei der die Gesamtwegstrecke am geringsten von der Baseline sowie die durchschnittliche Abweichung der Teilstrecken am geringsten ist<br>
Output: 5 Spatial Tasks so sortiert, dass Gesamtwegstrecke sich Baseline angleicht<br><br><br>



<h4>Technische Umsetzung:</h4><br>

<h5>Verwendete Frameworks(jeweils mit weblink):</h5>

node.js für die Implementierung der Server sowie der javascript-Funktionen <br>
mongo DB für die Implementierung der Datenbank <br>
Bootstrap für Teile der Website <br>
openlayer für die Einbindung der Karte<br>
OpenStreetMap für die Daten der Karte<br><br> <br>


<h4>Einbindung der Applikation in die Website:</h4><br>

Eine direkte Einbindung der Applikation in die Dokumentation ist nicht möglich, da die Dokumentation Teil der Webapplikation ist. Deswegen gelangt man hier zum:<br> <br>

Start der Schnitzeljagd(weblink)
Erstellen eines Tasks(weblink)<br> <br><br>



<h4>Evaluation gegenüber Baseline:</h4><br>

Der zeitintensivste Verarbeitungsschritt beim Erstellen einer Schnitzeljagd ist die Suche nach 5 passenden Rätseln. Als Baseline dient hier die lineare Suche auf einer Liste, in der alle Tasks enthalten sind, wobei die ersten 5 passenden Tasks ausgewählt werden. Das erfordert durchschnittlich 1/2 * n Vergleiche, wenn n Tasks in der Datenbank sind. Die Zeitkomplexität hierfür ist O(n).<br> <br>

Das Einfügen eines neuen Tasks in die DB ist bei einer sortierten Liste mit linearer Suche eine Operation linearer Komplexität, da ein neuer Task einfach an der der Sortierung entsprechenden Stelle in der Liste eingefügt wird, also O(n).<br> <br><br>





<h4>Downloads:</h4><br>
Präsentation<br>
SourceCode

<br><br> <br><br> <br>


Copyrights by Julia Kinshofer, Benjamin Sauer, Daniel Basaran. 2015


        </div>

    </div>
    <!-- /container -->

</body>

</html>
